\documentclass[]{article}
\usepackage{amssymb}
\usepackage{algorithmic}
\usepackage{hyperref}

\title{ARX64}
\author{
	Evan Saulpaugh\\
	\href{mailto:evan.saulpaugh@gmail.com}{evan.saulpaugh@gmail.com}
}
\date{August 13, 2015 (in progress)}

\begin{document}
% \maketitle
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\
\hfill\\


\abbazabba

% begin good stuff
\hfill\\
\textbf{Abstract.} {Just messing around with TeX. Not a paper yet. The ARX64 block cipher is designed to make efficient use of the 64-bit ALU width in modern processors. The keyed avalanche function, using one data-dependent rotation per 64-bit word per round, allows the algorithm to achieve a diffuse 256-bit ciphertext block after only two rounds. A psuedorandom number generator leveraging avalanche function serves as a key schedule.}

\section{Introduction}

Supports key sizes of 128, 192, and 256 bits.

\begin{table}[h!]
	\begin{center}
		\textbf{Table 1. }{Notation}\\
		\hfill \\
		\begin{tabular}{cl}
			Notation & Description\\
			\hline
			$x + y$ & addition of $x$ and $y$ modulo $2^n$\\
			$x * y$ & multiplication of $x$ and $y$ modulo $2^n$\\
			$x \oplus y$ & bitwise XOR of $x$ and $y$\\
			$x\land y$ & bitwise AND of $x$ and $y$\\
			$x\gg i$ & right shift of $x$ by $i$ bits\\
			$x\ggg i$ & right rotation of $x$ by $i$ bits\\
			\hline
		\end{tabular}
	\end{center}
\end{table}

\section{Description}
\subsection[]{Algorithm}
Let $P = (P_1,P_2,P_3,P_4)$ and $C = C_1,C_2,C_3,C_4)$ be the 256-bit block of plaintext and ciphertext respectively where $P_i$ and $C_i$ are 64-bit words. Let $SK_j$ be the 64-bit subkey for $j = 1,...,16$. Then, the encryption process is given as in Algorithm 1.
\\
\rule{\linewidth}{0.8pt}\\
\textbf{Algorithm 1 }{The Encryption Process of ARX64}\\
\rule{\linewidth}{0.4pt}
\begin{algorithmic}
	\STATE $(T_1,T_2,T_3,T_4) = P = (P_1,P_2,P_3,P_4)$
	\STATE $SK = (SK_1,SK_2,...,SK_{16})$
	\FOR {$i = 0$ to 2}
	\STATE $j = i * 4$
	\STATE $(RK_1,RK_2,RK_3,RK_4) = {SK_j,SK_{j+1},SK_{j+2},SK_{j+3}}$
	\STATE $T_1 = A(T_1, T_2 + T_3 + T_4 + RK_1)$
	\STATE $T_2 = A(T_2, T_1 + T_3 + T_4 + RK_2)$
	\STATE $T_3 = A(T_3, T_1 + T_2 + T_4 + RK_3)$
	\STATE $T_4 = A(T_4, T_1 + T_2 + T_3 + RK_4)$
	\ENDFOR
	\STATE $(C_1,C_2,C_3,C_4) = (T_1 \oplus SK_{13},T_2 \oplus SK_{14},T_3 \oplus SK_{15},T_4 \oplus SK_{16})$
\end{algorithmic}
\rule{\linewidth}{0.4pt}
\\
\\
\textbf {\textit{A}-Function } {{\textit{A}-Function is a keyed avalanche function with a 64-bit input that provides both confusion and diffusion. Used in the key schedule and in the encryption process.}\\
\\
\rule{\linewidth}{0.8pt}\\
\textbf{Algorithm 2 }{{\textit{A}-Function}\\
\rule{\linewidth}{0.4pt}\\
$A(X, S) = (Y)$\\
\indent $Y = (X + S) \ggg C(S)$\\
\rule{\linewidth}{0.4pt}\\
\\
\textbf {\textit{C}-Function } {{\textit{C}-Function is the compression function.}\\
\\
\rule{\linewidth}{0.8pt}\\
\textbf{Algorithm 3 }{{\textit{C}-Function}\\
\rule{\linewidth}{0.4pt}\\
$C(X) = (Y)$\\
\indent $X = (X \gg 32) + X$\\
\indent $X = (X \gg 11) \oplus X$\\
\indent $X = (X \gg 9) + X$\\
\indent $X = (X \gg 6) + X$\\
\indent $Y = X \land 0x3f$\\
\rule{\linewidth}{0.4pt}\\

\subsection[]{Key Schedule}
The 16 subkeys necessary for the encryption process are generated by seeding a psuedorandom number generator with the encryption key. Let the encryption key $K$ be equal to $(K_1,K_2,K_3,K_4)$, $(K_1,K_2,K_3)$, and $(K_1,K_2)$ for key lengths 256, 192, and 128 bits respectively, where each $K_i$ is a 64-bit word. Let the 320-bit PRNG seed $S = (S_1,S_2,S_3,S_4,S_5)$ be equal to $(K_1,K_2,K_3,K_4,C)$, $(K_1,K_2,K_3,C,C)$, and $(K_1,K_2,C,C,C)$ for key lengths 256, 192, and 128 bits respectively, where $C = 4142135623730950488$ and $S_i$, $K_i$, and $C$ are 64-bit words. Then, the key schedule is given as in Algorithm 4.
\\
\rule{\linewidth}{0.8pt}\\
\textbf{Algorithm 4 }{The Key Scheduling Algorithm}\\
\rule{\linewidth}{0.4pt}
\begin{algorithmic}
	\FOR{$i = 1$ to 10} 
	\STATE $(S,Y) = N(S)$
	\ENDFOR
	\STATE $SK = (SK_1,SK_2,...,SK_{16})$
	\FOR{$i = 1$ to 16}
	\STATE $(S,Y) = N(S)$
	\STATE $SK_i = Y$
	\ENDFOR
\end{algorithmic}
\rule{\linewidth}{0.4pt}\\
\rule{\linewidth}{0.8pt}\\
\textbf{Algorithm 5 }{{\textit{N}-Function is a psuedorandom number generator with 320 bits of state which uses the avalanche function to generate a series of 64-bit outputs.}\\
\rule{\linewidth}{0.4pt}\\
$N(S) = (S,Y)$\\
\indent $S = (S_1,S_2,S_3,S_4,S_5)$\\
\indent $Y = S_1 = A(S_1,S_1 \oplus S_2)$\\
\indent $S_2 = S_3$\\
\indent $S_3 = S_4$\\
\indent $S_4 = S_5$\\
\indent $S_5 = S_1$\\
\rule{\linewidth}{0.4pt}\\
\section[]{Design Rationale}

$C$-Function is optimized to effectively propagate one-bit changes at the various bit positions to the least significant six bits in the 64-bit input, resulting in a good distribution of 6-bit values.

\end{document}
