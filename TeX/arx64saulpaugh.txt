\documentclass[]{article}
\usepackage{amssymb}
\usepackage{algorithmic}
\usepackage{hyperref}
\usepackage[toc,page]{appendix}
\usepackage{listings}
\lstset{language=C}  

\title{XCRUSH/ARX64}
\author{
	Evan Saulpaugh\\
	\href{mailto:evan.saulpaugh@gmail.com}{evan.saulpaugh@gmail.com}
}
\date{August 18, 2015 (in progress)}

\begin{document}
\maketitle

% begin good stuff
\hfill\\
\textbf{Abstract.} {Just messing around with TeX. Not a paper yet. The ARX64 block cipher family is designed to make efficient use of the 64-bit ALU width in modern general-purpose processors. The keyed avalanche function, using one data-dependent rotation per 64-bit word of plaintext per round, allows the algorithm to achieve a diffuse 256-bit ciphertext block super quick and stuff. A psuedorandom number generator leveraging avalanche function serves as a key schedule.\\
	\\
	Designed for speed and simplicity.\\
	$\sim$7.3 cycles/byte measured\\
	No security claims made in this paper.}

\section{Introduction}

ARX64 supports key sizes of 128, 192, and 256 bits.

\begin{table}[h!]
	\begin{center}
		\textbf{Table 1. }{Notation}\\
		\hfill \\
		\begin{tabular}{cl}
			Notation & Description\\
			\hline
			$x + y$ & addition of $x$ and $y$ modulo $2^n$\\
			$x * y$ & multiplication of $x$ and $y$ modulo $2^n$\\
			$x \oplus y$ & bitwise XOR of $x$ and $y$\\
			$x\land y$ & bitwise AND of $x$ and $y$\\
			$x\gg i$ & right shift of $x$ by $i$ bits\\
			$x\lll i$ & left rotation of $x$ by $i$ bits\\
			\hline
		\end{tabular}
	\end{center}
\end{table}

\section{Description}
\subsection[]{Algorithm}
Let $P = (P_1,P_2,P_3,P_4)$ and $C = C_1,C_2,C_3,C_4)$ be the 256-bit plaintext and ciphertext respectively where $P_i$ and $C_i$ are 64-bit words. Let $SK_j$ be the 64-bit subkey for $j = 1,...,16$. Then, the encryption process can be formulated as in Algorithm 1.
\\
\rule{\linewidth}{0.8pt}\\
\textbf{Algorithm 1 }{The Encryption Process of ARX64}\\
\rule{\linewidth}{0.4pt}
\begin{algorithmic}
	\STATE $(T_1,T_2,T_3,T_4) = P = (P_1,P_2,P_3,P_4)$
	\STATE $SK = (SK_1,SK_2,...,SK_{16})$
	\FOR {$i = 0$ to 2}
	\STATE $j = i * 4$
	\STATE $(RK_1,RK_2,RK_3,RK_4) = {SK_j,SK_{j+1},SK_{j+2},SK_{j+3}}$
	\STATE $T_1 = A(T_1, T_2 + T_3 + T_4 + RK_1)$
	\STATE $T_2 = A(T_2, T_1 + T_3 + T_4 + RK_2)$
	\STATE $T_3 = A(T_3, T_1 + T_2 + T_4 + RK_3)$
	\STATE $T_4 = A(T_4, T_1 + T_2 + T_3 + RK_4)$
	\ENDFOR
	\STATE $(C_1,C_2,C_3,C_4) = (T_1 \oplus SK_{13},T_2 \oplus SK_{14},T_3 \oplus SK_{15},T_4 \oplus SK_{16})$
\end{algorithmic}
\rule{\linewidth}{0.4pt}
\\
\\
\textbf {\textit{A}-Function } {{\textit{A}-Function is a keyed avalanche function that provides both confusion and diffusion. The result of $C$-Function, an integer on interval [0,63], is used as the bitwise leftward rotation distance. $A$-Function is used in the encryption process and as part of the key expansion. Where $X$ and $A$ are 64-bit words, \textit{A}-Function can be formulated as in Algorithm 2.}
\\
\rule{\linewidth}{0.8pt}\\
\textbf{Algorithm 2 }{{\textit{A}-Function}\\
\rule{\linewidth}{0.4pt}\\
$A(X, A) = (Y)$\\
\indent $Y = (X + A) \lll C(A)$\\
\rule{\linewidth}{0.4pt}\\
\\
% $L(X)$ returns the least significant six bits of $X$
\textbf {\textit{C}-Function } {{\textit{C}-Function is a compression designed to produce a large set of values when applied to a set of very similar inputs. Where $X$ is a 64-bit word, \textit{C}-Function can be formulated as in Algorithm 3.}
\\
\rule{\linewidth}{0.8pt}\\
\textbf{Algorithm 3 }{{\textit{C}-Function}\\
\rule{\linewidth}{0.4pt}\\
$C(X) = (Y)$\\
\indent $X = (X \gg 32) + X$\\
\indent $X = (X \gg 11) \oplus X$\\
\indent $X = (X \gg 9) + X$\\
\indent $X = (X \gg 6) + X$\\
\indent $Y = X \land 0x3f$\\
\rule{\linewidth}{0.4pt}\\

\subsection[]{Key Expansion}
The 16 64-bit subkeys necessary for the encryption process are generated by seeding a psuedorandom number generator with the encryption key. Let the encryption key $K$ be equal to $(K_1,K_2)$, $(K_1,K_2,K_3)$, and $(K_1,K_2,K_3,K_4)$ for key lengths 128, 192, and 256 bits respectively, where each $K_i$ is a 64-bit word. Let the 320-bit PRNG seed $S = (S_1,S_2,S_3,S_4,S_5)$ be equal to $(K_1,K_2,C,C,C)$, $(K_1,K_2,K_3,C,C)$, and $(K_1,K_2,K_3,K_4,C)$ for key lengths 128, 192, and 256 bits respectively, where $C = 4142135623730950488$ and $S_i$, $K_i$, and $C$ are 64-bit words. Then, the key expansion can be formulated as in Algorithm 4.
\\
\rule{\linewidth}{0.8pt}\\
\textbf{Algorithm 4 }{The Key Expansion Algorithm}\\
\rule{\linewidth}{0.4pt}
\begin{algorithmic}
	\FOR{$i = 1$ to 10} 
	\STATE $(Y,S) = N(S)$
	\ENDFOR
	\STATE $SK = (SK_1,SK_2,...,SK_{16})$
	\FOR{$i = 1$ to 16}
	\STATE $(Y,S) = N(S)$
	\STATE $SK_i = Y$
	\ENDFOR
\end{algorithmic}
\rule{\linewidth}{0.4pt}\\
\rule{\linewidth}{0.8pt}\\
\textbf{Algorithm 5 }{{\textit{N}-Function is a psuedorandom number generator with 320 bits of state which uses the avalanche function to generate a series of 64-bit outputs.}\\
\rule{\linewidth}{0.4pt}\\
$N(S) = (Y,S)$\\
\indent $S = (S_1,S_2,S_3,S_4,S_5)$\\
\indent $T = S_2$\\
\indent $S_2 = S_3$\\
\indent $S_3 = S_4$\\
\indent $S_4 = S_5$\\
\indent $S_5 = S_1$\\
\indent $Y = S_1 = S_1 + A(S_1, T \oplus (T \ll 13))$\\
\indent $S = (S_1,S_2,S_3,S_4,S_5)$\\
\rule{\linewidth}{0.4pt}\\
\section[]{Design Rationale}

\subsection[]{Algorithm}

By making the addition to, but more importantly the bitwise rotation of each 64-bit word of plaintext dependent on the other three words in the plaintext block, and by allowing the output of one avalanche operation to feed into the next, we can ensure that a small change in the plaintext block will tend to result in a very large change in the output block after only one round.\\
\\
All three variants have same number of rounds.\\
\\
Given this construction, it appeared natural to simply add a 64-bit word of key material to the sum of the words of plaintext going into the avalanche function. In this way of applying key material with every invokation, confusion and diffusion are achieved efficiently and simultaneously.

\subsection[]{Key Expansion}

Chosen for speed and simplicity of implementation.\\
\\
The complex one-way nature of the key expansion is intended to make it difficult for an attacker to use information about a subkey to recover infomation about the other subkeys or about the master key. Additionally, the PRNG method of subkey derivation, by which a stream of subkeys is dependent on all the bits of the master key, is intended to mitigate related key attacks.\\
\\
The constant $C$, namely the leading decimal digits of the fractional part of the square root of two, is arbitrarily chosen to ensure that the PRNG is not seeded with all zeros.

\section{Security Analysis}

None.

\section{Concluding Remarks}

ARX64 may eventually be found suitable for stuff. Ambitious.

\section*{References}

\newpage
\begin{appendices}
\section{Test Vectors}
\subsection{XCRUSH-128}
\begin{lstlisting}
KEY:
    00000000000000000000000000000000
PLAINTEXT:
    0000000000000000000000000000000000000000000000000000000000000000
CIPHERTEXT:
    BF86222813D1FCD0EC8D1E7720F6AFF13E898865E008547E9AC5C001B239DF98

KEY:
    0000000000000000000000000000000000000000000000000000000000000000
PLAINTEXT:
    FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
CIPHERTEXT:
    C32957267441E1F9DE3AF89DBF6A99953E013580F3BE31C7D1E856D3CB284AB7

KEY:
    FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
PLAINTEXT:
    0000000000000000000000000000000000000000000000000000000000000000
CIPHERTEXT:
    EC6ED4A2CE9DFDE744C74D6EFBB91C4039257462013756ECF99ED69956FD3603

KEY:
    FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
PLAINTEXT:
    FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
CIPHERTEXT:
    24F9111F67473D1409E4B5117F6C54655B49C861920BF44436D23C3B4D8F015
    
KEY:
    7612FCBC803B4246A3549E0E29EF838A
PLAINTEXT:
    F8D9BC0A57B6215FE901E11A1B2FF5E9E13A217EA06A02AED4B0DB34F760A72D
CIPHERTEXT:
    B4A85B4B29C12A83B88C6B7DC923933A95E3088D6DE37B96714F5ECE1E31BDDB
\end{lstlisting}
\newpage
\subsection{XCRUSH-192}
\begin{lstlisting}
KEY:
    000000000000000000000000000000000000000000000000
PLAINTEXT:
    0000000000000000000000000000000000000000000000000000000000000000
CIPHERTEXT:
    4E7E2FA9E431DD97C9F565D5E7457CE2E8E7A88A3D2E95BBCABE12F209E6EDBF

KEY:
    000000000000000000000000000000000000000000000000
PLAINTEXT:
    FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
CIPHERTEXT:
    23E0445396EE071511E6A189253C6662906C002D08859573604A8713E06536D7

KEY:
    FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
PLAINTEXT:
    0000000000000000000000000000000000000000000000000000000000000000
CIPHERTEXT:
    6D5E4C5168C84DD1F9CF9D6EA8D1A7CC84725DBFE3D6BF2042D2A076FDCA1138

KEY:
    FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
PLAINTEXT:
    FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
CIPHERTEXT:
    6C2E5A347379FD102D3B43C2CDDBA96C15B5C13478B8947D341C860CEE2BBBB8
    
KEY:
    7612FCBC803B4246A3549E0E29EF838AA401BD204B4BD836
PLAINTEXT:
    F8D9BC0A57B6215FE901E11A1B2FF5E9E13A217EA06A02AED4B0DB34F760A72D
CIPHERTEXT:
    41052B4F0F9003DD46316063F568410E1849A66A064D43DE34A1C1403F3AB861
\end{lstlisting}
\newpage
\subsection{XCRUSH-256}
\begin{lstlisting}
KEY:
    0000000000000000000000000000000000000000000000000000000000000000
PLAINTEXT:
    0000000000000000000000000000000000000000000000000000000000000000
CIPHERTEXT:
    3300BA8DCBA750AAD1391F3480B7E8FAE3E327F03C224B5A17321CC438A0B80B
    
KEY:
    0000000000000000000000000000000000000000000000000000000000000000
PLAINTEXT:
    FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
CIPHERTEXT:
    4221D8D6702465263C23643850A9D890B27253A559C655D7BE4E85B54A35B78F
    
KEY:
    FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
PLAINTEXT:
    0000000000000000000000000000000000000000000000000000000000000000
CIPHERTEXT:
    DDC09E621D4F8075A58E26BFA3D9750722B13B1B1C972A654ECC7F1C28AB088D
        
KEY:
    FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
PLAINTEXT:
    FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
CIPHERTEXT:
    D90F53470056919594CF8B5A6C7A909FB1FE795A648D60C2E2266439173156BA
    
KEY:
    7612FCBC803B4246A3549E0E29EF838AA401BD204B4BD836A1E2B532FB045279
PLAINTEXT:
    F8D9BC0A57B6215FE901E11A1B2FF5E9E13A217EA06A02AED4B0DB34F760A72D
CIPHERTEXT:
    269E956A88999FF7F16DBE0FF0122C2071C8E338457FDC26B2DDC6FD211360C7
 
\end{lstlisting}
\newpage
\section{Reference Implementation}
\begin{lstlisting}
/*
The C reference implementation of the
block cipher XCRUSH (in progress)

Copyright (C) 2015 Evan Saulpaugh

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <stdio.h>
//#include <stdlib.h>
//#include <time.h>
//#include <unistd.h>
//#include <stdint.h>
//#include <inttypes.h>

#define BLOCK_LENGTH_LONGS 4
#define KEY_LEN_128_BITS 2
#define KEY_LEN_192_BITS 3
#define KEY_LEN_256_BITS 4
#define NUM_SUBKEYS 16
#define C 4142135623730950488

int compress(unsigned long long x) {
    x = (x >> 32) + x;
    x = (x >> 11) ^ x;
    x = (x >> 9) + x;
    return ((x >> 6) + x) & 0x3f;
}

long long avalanche(unsigned long long v, unsigned long long a) {
    v += a;
    const int shiftAmount = compress(a);
    return (v << shiftAmount) | (v >> -shiftAmount);// ROTATE LEFT
}

long long unavalanche(unsigned long long v, unsigned long long a) {
    const int shiftAmount = compress(a);
    v = (v >> shiftAmount) | (v << -shiftAmount);// ROTATE RIGHT
    return v - a;
}

void _encrypt(unsigned long long plaintext[], int offset, int length, unsigned long long subkeys[16]) {

    const long __0 = subkeys[0];
    const long __1 = subkeys[1];
    const long __2 = subkeys[2];
    const long __3 = subkeys[3];
    const long __4 = subkeys[4];
    const long __5 = subkeys[5];
    const long __6 = subkeys[6];
    const long __7 = subkeys[7];
    const long __8 = subkeys[8];
    const long __9 = subkeys[9];
    const long _10 = subkeys[10];
    const long _11 = subkeys[11];

    const long _12 = subkeys[12];
    const long _13 = subkeys[13];
    const long _14 = subkeys[14];
    const long _15 = subkeys[15];

    const int end = offset + length;

    int one___, two___, three_;

    long a_, b_, c_, d_, temp;

    // for each block
    for ( ; offset < end; offset += BLOCK_LENGTH_LONGS) {

        one___ = offset + 1;
        two___ = offset + 2;
        three_ = offset + 3;

        a_ = plaintext[offset];
        b_ = plaintext[one___];
        c_ = plaintext[two___];
        d_ = plaintext[three_];

        /* round 1 */
        temp = c_ + d_;
        a_ = avalanche(a_, temp + b_ + __0);
        b_ = avalanche(b_, temp + a_ + __1);
        temp = a_ + b_;
        c_ = avalanche(c_, temp + d_ + __2);
        d_ = avalanche(d_, temp + c_ + __3);

        /* round 2 */
        temp = c_ + d_;
        a_ = avalanche(a_, temp + b_ + __4);
        b_ = avalanche(b_, temp + a_ + __5);
        temp = a_ + b_;
        c_ = avalanche(c_, temp + d_ + __6);
        d_ = avalanche(d_, temp + c_ + __7);

        /* round 3 */
        temp = c_ + d_;
        a_ = avalanche(a_, temp + b_ + __8);
        b_ = avalanche(b_, temp + a_ + __9);
        temp = a_ + b_;
        c_ = avalanche(c_, temp + d_ + _10);
        d_ = avalanche(d_, temp + c_ + _11);

        plaintext[offset] = a_ ^ _12;
        plaintext[one___] = b_ ^ _13;
        plaintext[two___] = c_ ^ _14;
        plaintext[three_] = d_ ^ _15;
    }
}

void decrypt(unsigned long long ciphertext[], int offset, int length, unsigned long long subkeys[16]) {

    const long __0 = subkeys[0];
    const long __1 = subkeys[1];
    const long __2 = subkeys[2];
    const long __3 = subkeys[3];
    const long __4 = subkeys[4];
    const long __5 = subkeys[5];
    const long __6 = subkeys[6];
    const long __7 = subkeys[7];
    const long __8 = subkeys[8];
    const long __9 = subkeys[9];
    const long _10 = subkeys[10];
    const long _11 = subkeys[11];

    const long _12 = subkeys[12];
    const long _13 = subkeys[13];
    const long _14 = subkeys[14];
    const long _15 = subkeys[15];

    const int end = offset + length;

    int one___, two___, three_;

    long a_, b_, c_, d_, temp;

    for ( ; offset < end; offset += BLOCK_LENGTH_LONGS) {

        one___ = offset + 1;
        two___ = offset + 2;
        three_ = offset + 3;

        a_ = ciphertext[offset] ^ _12;
        b_ = ciphertext[one___] ^ _13;
        c_ = ciphertext[two___] ^ _14;
        d_ = ciphertext[three_] ^ _15;

        temp = a_ + b_;
        d_ = unavalanche(d_, temp + c_ + _11);
        c_ = unavalanche(c_, temp + d_ + _10);
        temp = c_ + d_;
        b_ = unavalanche(b_, temp + a_ + __9);
        a_ = unavalanche(a_, temp + b_ + __8);

        temp = a_ + b_;
        d_ = unavalanche(d_, temp + c_ + __7);
        c_ = unavalanche(c_, temp + d_ + __6);
        temp = c_ + d_;
        b_ = unavalanche(b_, temp + a_ + __5);
        a_ = unavalanche(a_, temp + b_ + __4);

        temp = a_ + b_;
        d_ = unavalanche(d_, temp + c_ + __3);
        c_ = unavalanche(c_, temp + d_ + __2);
        temp = c_ + d_;
        b_ = unavalanche(b_, temp + a_ + __1);
        a_ = unavalanche(a_, temp + b_ + __0);

        ciphertext[offset] = a_;
        ciphertext[one___] = b_;
        ciphertext[two___] = c_;
        ciphertext[three_] = d_;
    }
}

long long S_1,  S_2,  S_3,  S_4,  S_5;

long long next() {
    long long t = S_2;
    S_2 = S_3;
    S_3 = S_4;
    S_4 = S_5;
    S_5 = S_1;
    S_1 = S_1 + avalanche(S_1, t ^ (t << 13));
    return S_1;
}

void expand_key(unsigned long long key[], int keyLen, unsigned long long subkeybuf[NUM_SUBKEYS]) {
    switch (keyLen) {
    case KEY_LEN_128_BITS:
        S_1 = key[0];
        S_2 = key[1];
        S_3 = C;
        S_4 = C;
        S_5 = C;
        break;
    case KEY_LEN_192_BITS:
        S_1 = key[0];
        S_2 = key[1];
        S_3 = key[2];
        S_4 = C;
        S_5 = C;
        break;
    case KEY_LEN_256_BITS:
        S_1 = key[0];
        S_2 = key[1];
        S_3 = key[2];
        S_4 = key[3];
        S_5 = C;
        break;
    default:
        break;
    }

    for(int i = 0; i < 10; i++) {
        next();
    }
    for(int i = 0; i < NUM_SUBKEYS; i++) {
        subkeybuf[i] = next();
    }
}

int main(int argc, const char * argv[]) {

    const int keyLen = KEY_LEN_256_BITS;
    unsigned long long key[keyLen] = { 0,0,0,0 };
    unsigned long long subkeys[NUM_SUBKEYS];
    expand_key(key, keyLen, subkeys);

    const int dataLen = 4;//
    unsigned long long data[dataLen] = { 0,0,0,0 };

    for(int i = 0; i < dataLen; i++) {
        printf("%#llx ", data[i]);
    }

    printf("\n");

    _encrypt(data, 0, dataLen, subkeys);

    for(int i = 0; i < dataLen; i++) {
        printf("%#llx ", data[i]);
    }

    printf("\n");

    decrypt(data, 0, dataLen, subkeys);

    for(int i = 0; i < dataLen; i++) {
        printf("%#llx ", data[i]);
    };

    return 0;
}

\end{lstlisting}
\end{appendices}

% add references

\end{document}
