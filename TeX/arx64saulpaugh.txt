\documentclass[]{article}
\usepackage{amssymb}
\usepackage{algorithmic}
\usepackage{hyperref}

\title{The Camp's Ice Cream}
\author{
	Evan Saulpaugh\\
	\href{mailto:evan.saulpaugh@gmail.com}{evan.saulpaugh@gmail.com}
}
\date{August 18, 2015 (in progress)}

\begin{document}
\maketitle

% begin good stuff
\hfill\\
\textbf{Abstract.} {Just messing around with TeX. Not a paper yet. The ARX64 block cipher is designed to make efficient use of the 64-bit ALU width in modern general-purpose processors. The keyed avalanche function, using one data-dependent rotation per 64-bit word of plaintext per round, allows the algorithm to achieve a diffuse 256-bit ciphertext block after only two rounds. A psuedorandom number generator leveraging avalanche function serves as a key schedule.}

\section{Introduction}

ARX64 supports key sizes of 128, 192, and 256 bits.

\begin{table}[h!]
	\begin{center}
		\textbf{Table 1. }{Notation}\\
		\hfill \\
		\begin{tabular}{cl}
			Notation & Description\\
			\hline
			$x + y$ & addition of $x$ and $y$ modulo $2^n$\\
			$x * y$ & multiplication of $x$ and $y$ modulo $2^n$\\
			$x \oplus y$ & bitwise XOR of $x$ and $y$\\
			$x\land y$ & bitwise AND of $x$ and $y$\\
			$x\gg i$ & right shift of $x$ by $i$ bits\\
			$x\ggg i$ & right rotation of $x$ by $i$ bits\\
			\hline
		\end{tabular}
	\end{center}
\end{table}

\section{Description}
\subsection[]{Algorithm}
Let $P = (P_1,P_2,P_3,P_4)$ and $C = C_1,C_2,C_3,C_4)$ be the 256-bit plaintext and ciphertext respectively where $P_i$ and $C_i$ are 64-bit words. Let $SK_j$ be the 64-bit subkey for $j = 1,...,16$. Then, the encryption process can be formulated as in Algorithm 1.
\\
\rule{\linewidth}{0.8pt}\\
\textbf{Algorithm 1 }{The Encryption Process of ARX64}\\
\rule{\linewidth}{0.4pt}
\begin{algorithmic}
	\STATE $(T_1,T_2,T_3,T_4) = P = (P_1,P_2,P_3,P_4)$
	\STATE $SK = (SK_1,SK_2,...,SK_{16})$
	\FOR {$i = 0$ to 2}
	\STATE $j = i * 4$
	\STATE $(RK_1,RK_2,RK_3,RK_4) = {SK_j,SK_{j+1},SK_{j+2},SK_{j+3}}$
	\STATE $T_1 = A(T_1, T_2 + T_3 + T_4 + RK_1)$
	\STATE $T_2 = A(T_2, T_1 + T_3 + T_4 + RK_2)$
	\STATE $T_3 = A(T_3, T_1 + T_2 + T_4 + RK_3)$
	\STATE $T_4 = A(T_4, T_1 + T_2 + T_3 + RK_4)$
	\ENDFOR
	\STATE $(C_1,C_2,C_3,C_4) = (T_1 \oplus SK_{13},T_2 \oplus SK_{14},T_3 \oplus SK_{15},T_4 \oplus SK_{16})$
\end{algorithmic}
\rule{\linewidth}{0.4pt}
\\
\\
\textbf {\textit{A}-Function } {{\textit{A}-Function is a keyed avalanche function that provides both confusion and diffusion. This function is used in the encryption process and as part of the key expansion. Where $X$ and $A$ are 64-bit words, \textit{A}-Function can be formulated as in Algorithm 2.}
\\
\rule{\linewidth}{0.8pt}\\
\textbf{Algorithm 2 }{{\textit{A}-Function}\\
\rule{\linewidth}{0.4pt}\\
$A(X, A) = (Y)$\\
\indent $Y = (X + A) \ggg C(A)$\\
\rule{\linewidth}{0.4pt}\\
\\
\textbf {\textit{C}-Function } {{\textit{C}-Function is a compression designed to produce a large set of values when applied to a set of very similar inputs. The output is a bitwise rotation distance on interval [0,63] to be used by the avalanche function. Where $X$ is a 64-bit word and $L(X)$ returns the least significant six bits of $X$, \textit{C}-Function can be formulated as in Algorithm 3.}
\\
\rule{\linewidth}{0.8pt}\\
\textbf{Algorithm 3 }{{\textit{C}-Function}\\
\rule{\linewidth}{0.4pt}\\
$C(X) = (Y)$\\
\indent $X = (X \gg 32) + X$\\
\indent $X = (X \gg 11) \oplus X$\\
\indent $X = (X \gg 9) + X$\\
\indent $X = (X \gg 6) + X$\\
\indent $Y = L(X)$\\
\rule{\linewidth}{0.4pt}\\

\subsection[]{Key Expansion}
The 16 64-bit subkeys necessary for the encryption process are generated by seeding a psuedorandom number generator with the encryption key. Let the encryption key $K$ be equal to $(K_1,K_2,K_3,K_4)$, $(K_1,K_2,K_3)$, and $(K_1,K_2)$ for key lengths 256, 192, and 128 bits respectively, where each $K_i$ is a 64-bit word. Let the 320-bit PRNG seed $S = (S_1,S_2,S_3,S_4,S_5)$ be equal to $(K_1,K_2,K_3,K_4,C)$, $(K_1,K_2,K_3,C,C)$, and $(K_1,K_2,C,C,C)$ for key lengths 256, 192, and 128 bits respectively, where $C = 4142135623730950488$ and $S_i$, $K_i$, and $C$ are 64-bit words. Then, the key schedule can be formulated as in Algorithm 4.
\\
\rule{\linewidth}{0.8pt}\\
\textbf{Algorithm 4 }{The Key Expansion Algorithm}\\
\rule{\linewidth}{0.4pt}
\begin{algorithmic}
	\FOR{$i = 1$ to 10} 
	\STATE $(S,Y) = N(S)$
	\ENDFOR
	\STATE $SK = (SK_1,SK_2,...,SK_{16})$
	\FOR{$i = 1$ to 16}
	\STATE $(S,Y) = N(S)$
	\STATE $SK_i = Y$
	\ENDFOR
\end{algorithmic}
\rule{\linewidth}{0.4pt}\\
\rule{\linewidth}{0.8pt}\\
\textbf{Algorithm 5 }{{\textit{N}-Function is a psuedorandom number generator with 320 bits of state which uses the avalanche function to generate a series of 64-bit outputs.}\\
\rule{\linewidth}{0.4pt}\\
$N(S) = (S,Y)$\\
\indent $S = (S_1,S_2,S_3,S_4,S_5)$\\
\indent $Y = S_1 = A(S_1,S_1 \oplus S_2)$\\
\indent $S_2 = S_3$\\
\indent $S_3 = S_4$\\
\indent $S_4 = S_5$\\
\indent $S_5 = S_1$\\
\rule{\linewidth}{0.4pt}\\
\section[]{Design Rationale}

\subsection[]{Algorithm}

By making the addition to, but more importantly the bitwise rotation of each 64-bit word of plaintext dependent on the other three words in the plaintext block, and by allowing the output of one avalanche operation to feed into the next, we can ensure that a small change in the plaintext block will tend to result in a very large change in the output block after only one round.\\
\\
Given this construction, it appeared natural to simply add a 64-bit word of key material to the sum of the words of plaintext going into the avalanche function. In this way of applying key material with every invokation, confusion and diffusion are achieved efficiently and simultaneously.

\subsection[]{Key Expansion}

The complex one-way nature of the key expansion is intended to make it difficult for an attacker to use information about a subkey to recover infomation about the other subkeys or about the master key. Additionally, the PRNG method of subkey derivation, by which a stream of subkeys is dependent on all the bits of the master key, is intended to mitigate related key attacks.\\
\\
The constant $C$, namely the leading decimal digits of the fractional part of the square root of two, is arbitrarily chosen to ensure that the PRNG is not seeded with all zeros.

\section{Security Analysis}

None.

\section{Concluding Remarks}

ARX64 may eventually be found suitable for stuff.

\section*{References}

% add references

\end{document}
